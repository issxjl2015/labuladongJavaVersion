# 动态规划答疑：最优子结构及 dp 遍历方向

本节主要讨论两个问题：
> 1、什么是 “最优子结构”， 和 动态规划 是什么关系？   
> 2、为什么动态规划遍历 dp 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历？  

## 1、最优子结构详解
1、想满足最优子结构，子问题之间必须互相独立。  
2、最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；  
3、但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的。  
4、找最优子结构的过程，其实就是 证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了。  

## 2、dp 数组的遍历方向

1、dp 数组不同遍历方向：  
---
正向遍历：  
```java
int[][] dp = new int[m][n];
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        dp[i][j] = ...
    }
}
```
---
反向遍历：  
```java
for (int i = m - 1; i >= 0; i--) {
    for (int j = n - 1; j >= 0; j--) {
        dp[i][j] = ...
    }
}
```
---
斜着遍历：  
```java
for (int l = 2; l <= n; l++) {
    for (int i = 0; i <= n - l; i++) {
        int j = l + i - 1;
        dp[i][j] = ...
    }
}
```
---
2、遍历的原则：  
> 1、遍历的过程中，所需的状态必须是已经计算出来的。  
> 2、遍历的终点必须是存储结果的那个位置。  

编辑距离中，根据 dp 数组的定义：  
1、base case 是 dp[...][0] 和 dp[0][...]   
2、状态转移方程： dp[i][j] 要从 dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] 转移而来。  
那么怎么遍历呢：
```java
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        // 通过 dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]
        // 计算 dp[i][j]
    }   
}
```

这样的遍历方式，可以保证，每一步迭代的左边、右边、左上边的位置都是 base case，    
或者之前前计算过的，而且最终结束在我们想要的答案 dp[m][n].   

----
回文子序列中，根据 dp 数组的定义：   
1、base case 处于中间的对角线   
2、dp[i][j] 需要从 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 转移而来。   
最终想要求的答案是 dp[0][n - 1]. 有两种方式可以遍历：
---
倒着遍历：
```java
for (int i = n - 2; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        // 通过 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1]
        // 计算 dp[i][j]
    }
}
```
---
斜着遍历：
```java
// 变量 l 用来辅助斜向遍历
for (int l = 2; l <= n; l++) {
    for (int i = 0; i <= n - l; i++) {
        int j = l + i - 1;
        // 通过 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1]
        // 计算 dp[i][j]
    }
}
```
----

## 总结
1、根据遍历两原则，主要是看 base case 和 最终结果的存储位置，   
  保证遍历过程中使用的数据都是计算完毕的就行。   
2、动态规划问题最困难的是推导状态转移方程，base case 和 最终状态的位置都比较容易看出来。   
3、如果题目比较困难，可以先确定 base case 和 最终状态，然后 通过 它们的相对位置，来猜测状态转移方程，猜测 dp[i][j] 可能从哪些状态转移而来。   

