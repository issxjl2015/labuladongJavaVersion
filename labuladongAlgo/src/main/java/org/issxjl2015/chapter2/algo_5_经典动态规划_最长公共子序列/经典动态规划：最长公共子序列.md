# 经典动态规划：最长公共子序列

## 1、最长公共子序列问题
1、最长公共子序列（Longest Common Subsequence, 简称 LCS），是一道非常经典的面试题目，   
因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，   
比如编辑距离。而且，这个算法加以改造可以用于解决其他问题。   
2、“最长公共子序列” 问题就是让我们求出两个字符串的 LCS 长度。   
比如：输入 str1 = "abcde", str2 = "aceb"，算法应该输出 3， 因为 str1 和 str2 的最长公共子序列是 “ace”， 它的长度是 3。   

为啥要用动态规划来解决？   
> 因为子序列类型的问题，穷举出所有可能的结果不容易，而动态规划算法做的就是穷举 + 剪枝。   
> 只要涉及到 子序列问题， 十有八九需要动态规划来解决。   

## 2、动态规划思路
1、一定要明确 dp 数组的含义。
> dp[i][j] 的含义是：对于 s1[0..i-1] 和 s2[0..j-1], 它们的 LCS 长度是 dp[i][j].  
 
2、定义 base case。
> 1、专门让索引为0的行和列表示 空串。（只要有一个字符串是空串， LCS的长度肯定为 0）   
> 2、dp[0][..] 和 dp[..][0] 都应该初始化为 0， 这就是 base case。

3、找状态转移方程。
> 1、状态转移方程其实就是 “做选择”。  
> 2、“在‘ 与 ”不在“ 就是选择，如果某个字符在 LCS 中，那么这个字符肯定同时存在于 s1 和 s2 中。  
>> (1) dp(i, j) 表示 dp[0..i] 和 dp[0..j] 中最长公共子序列的长度，这样就可以找到状态转移方程了    
>>（2） 如果 s1[i] == s2[j], 说明公共字符一定存在于 LCS 中，如果知道 s1[0..i-1] 和 s2[0..j-1]中的 LCS 长度，再加上 1 就是 s1[0..i] 和 s2[0..j]中的 LCS 的长度。
>>```java
>>   if (s1.charAt(i) == s2.charAt(j)) {
>>       dp[i][j] = dp[i - 1][j - 1] + 1;
>>   }
>>```  
>>（3） 如果 s1[i] != s2[j], 说明 s1[i] 和 s2[j] 这两个字符至少有一个不在 LCS 中，那么哪个字符不在 LCS 中呢？都尝试一下呗，逻辑如下：    
>>```java
>>   if (s1.charAt(i) != s2.charAt(j)) {
>>        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
>>   }
>>```
----

4、明白了 状态转移方程，可以直接写出解法：
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        // base case
        // dp 数组初始化就是0，不用再次初始化了

        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 字符相同时，加入该字符到 LCS 中
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 字符不相同时，那么判断一下哪个字符在里面，
                    // 其实还有一个 dp[i - 1][j - 1]，但是由于 dp[i - 1][j - 1]肯定最小，max的时候，肯定取不到，所以不写了
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```

## 总结
找状态转移方程的方法就是思考每个状态有哪些 “选择”, 只要我们能用正确的逻辑做出正确的选择，算法就能够正确运行。   
