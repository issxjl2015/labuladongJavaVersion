# 经典动态规划：0-1 背包问题

## 动态规划标准套路
（1）第一步：“状态” 和 “选择”
- 状态：“背包的重量” 和 “可选择的物品”
- 选择：“装进背包” 或者 “不装进背包”
- 动态规划的框架：
```java
for 状态1 in 状态1 的所有取值：
    for 状态2 in 状态2 的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优 (选择1， 选择2 ...)
```
（2）第二步：明确 dp 数组的定义  
- 第一步中找到两个状态，也就是说，需要一个二维 dp 数组。
- dp[i][w] 的定义如下：
> 对于前 i 个物品，当前背包的容量是 w，这种情况下可以装的最大价值是 dp[i][w].   
- 根据这个定义，最终的答案就是 dp[N][W]。
> base case 就是 dp[0][...] = dp[...][0] = 0    
> 因为没有物品或者背包没有空间的时候，能装的最大价值就是 0

- 细化框架：
```java
int[][] dp = new int[N + 1][W + 1]
dp[0][...] = 0
dp[...][0] = 0

for i in [1..N]:
    for w in [1..W]:
        do[i][w] = max(
            把物品 i 装进背包，
            不把物品 i 装进背包
        )
return dp[N][W]   
```

（3）第三步：根据 “选择”，思考状态转移的逻辑
- 重申一下 dp 数组的定义：
> dp[i][w] 表示：对于前 i 个物品，当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]
- 如果没有把这第 i 个物品装入背包，那么最大价值 dp[i][w] 应该等于 dp[i - 1][w]
- 如果把这第 i 个物品装入背包，那么dp[i][w] 应该等于 dp[i - 1][w - wt[i - 1]] + val[i - 1]
> 由于 i 是 从 1 开始的，所以 val 和 wt 的索引是 i - 1 时表示第 i 个物品的价值和重量   
> dp[i - 1][w - wt[t - 1]]表示：如果装了第 i 个物品，就要寻求剩余重量 w - wt[t - 1] 限制下的最大价值，加上第 i 个物品的价值 val[i - 1]

综上，两种选择都已经分析完毕，就可以写出状态转移方程，进一步细化代码：
```java
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i - 1][w],
            dp[i - 1][w - wt[i - 1]] + val[i - 1]
        ) 
return dp[N][W]
```

（4）最后一步：把伪码翻译成代码，处理一些边界情况
```java
int knapsack(int W, int N, int[] wt, int[] val) {
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                // 背包容量不够了，这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                dp[i][w] = Math.max(dp[i - 1][w - wt[i - 1]] + val[i - 1],
                                dp[i - 1][w]);
            }
        }
    }
    return dp[N][W];
}
```

- 背包问题就解决了，相比较，这是一道比较简单的动态规划问题，  
- 因为状态转移的推导比较自然，基本明确了 dp 数组的定义，就可以确定状态转移。